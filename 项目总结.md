## 项目总结



#### 阅读器开发过程

建立了阅读器框架页面

```
index.vue
```



通过动态路由动态的向EbookReader组件传入电子书路径

```js
export default new Router({
  routes: [
    {
      path: '/',
      redirect: '/ebook'
    },
    {
      path: '/ebook',
      component: () => import('./views/ebook/index.vue'),
      children: [
        {
          path: ':fileName',
          component: () => import('./components/ebook/EbookReader.vue')
        }
      ]
    }
  ]
})
```



在EbookReader组建中实现了阅读器的解析和渲染

```js
// 阅读器解析
initEpub () {...}
```



通过 vue-cli 3.0  新建.env.development文件，管理引入环境变量

```js
.env.development
```

```js
VUE_APP_RES_URL=http://192.168.0.156:9000/
```



通过手势操作实现了电子书的翻页，主要通过rendition.on方法绑定了touchstart和touchend事件对手势进行识别

```js
this.rendition.on('touchstart', event => {
    ...
})
this.rendition.on('touchend', event => {
    ...
})
```



集成了阅读器的标题和菜单组件，集成了mixin和vuex机制对组件进行解耦

```js
mixin.js
book.js
actions.js
getters.js
index.js
```



实现了字体风格和字号设置，运用了localstorage缓存阅读器的配置，引入了vue-i18n国际化插件实现了中英文两种语言的切换

```js
localstorage.js

// vue-i18n的使用
// npm i --save vue-i18n
import VueI18n from 'vue-i18n'
Vue.use(VueI18n)
const i18n = new VueI18n({
  locale,
  messages
})
export default i18n
new Vue({
    i18n
})
```



实现了主题设置功能，分为两部分：

1. 阅读器的主题：阅读器的主题主要是通过Epubjs实现。核心方法是通过theme对象的register方法注册主题，select方法切换主题。

   ```js
   // 在 mixin.js 中定义阅读器的主题
   initGlobalStyle () {
       switch (this.defaultTheme) {
           case 'Default':
               addCss(`${process.env.VUE_APP_RES_URL}/theme/theme_default.css`)
             	break
           case 'Eye':
             	addCss(`${process.env.VUE_APP_RES_URL}/theme/theme_eye.css`)
             	break
           case 'Gold':
             	addCss(`${process.env.VUE_APP_RES_URL}/theme/theme_gold.css`)
             	break
           case 'Night':
             	addCss(`${process.env.VUE_APP_RES_URL}/theme/theme_night.css`)
             	break
           default:
               addCss(`${process.env.VUE_APP_RES_URL}/theme/theme_default.css`)
       }
   }
   
   // 在阅读器主题组件中定义设置的方法
   setTheme (index) {
       const theme = this.themeList[index]
       this.setDefaultTheme(theme.name).then(() => {
           this.currentBook.rendition.themes.select(this.defaultTheme)
           this.initGlobalStyle()  // 异步调用主题方法
       })
   }
   ```

2. App界面的主题：App界面的主题主要是通过动态添加删除css实现的

   ```js
   // 动态添加css
   export function addCss(href) {
     const link = document.createElement('link')
     link.setAttribute('rel', 'stylesheet')
     link.setAttribute('type', 'text/css')
     link.setAttribute('href', href)
     document.getElementsByTagName('head')[0].appendChild(link)
   }
   
   // 动态删除css
   export function removeCss (href) {
     const links = document.getElementsByTagName('link')
     for (let i = links.length; i >= 0; i--) {
       const link = links[i]
       if (link && link.getAttribute('href') && link.getAttribute('href') === href) {
         link.parentNode.removeChild(link)
       }
     }
   }
   ```


阅读进度的实现，使用了html5的range控件，通过Epubjs的locations对象实现了定位和阅读百分比的显示，还实现了上一章下一章以及获取当前名称还有阅读时间统计的功能

```html
<input
       class="progress"
       type="range"
       max="100"
       min="0"
       step="1"
       @change="onProgressChange($event.target.value)"
       @input="onProgressInput($event.target.value)"
       :value="progress"
       :disabled="!bookAvailable"
       ref="progress"
       >
```

```js
// 拖动进度条过程
onProgressInput (progress) {
	this.setProgress(progress).then(() => {
	this.updateProgressBackground()
   })
}
  
// 进度条拖动结束松手
onProgressChange (progress) {
	this.setProgress(progress).then(() => {
      this.displayProgress()
      this.updateProgressBackground()
    })
 }
 
// 展示当前进度所在的页面
displayProgress () {
  const cfi = this.currentBook.locations.cfiFromPercentage(this.progress / 100)
  this.display(cfi)
}

// 进度条左键头点击翻页
prevSection () {
  if (this.section > 0 && this.bookAvailable) {
    this.setSection(this.section - 1).then(() => {
      this.displaySection()
    })
  }
}

// 进度条右键头点击翻页
nextSection () {
  if (this.section < this.currentBook.spine.length - 1 && this.bookAvailable) {
    this.setSection(this.section + 1).then(() => {
      this.displaySection() 
    })
  }
}

// displaySection方法封装
displaySection () {
  const sectionInfo = this.currentBook.section(this.section)
  if (sectionInfo && sectionInfo.href) {
    this.display(sectionInfo.href)
  }
}
```



实现了阅读器的目录功能，掌握了如何解析电子书的内容，获取了电子书封面、作者、标题等信息，之后获取了目录的内容，值得一提的是封装了一个flatten方法，flatten方法运用了ES6的新特性，将一个树状结构转变为了一维数组，并运用find方法判断出了每一个对象所属的层级，实现了多级目录的缩进展示。

```js
// flatten方法
export function flatten (arr) {
  return [].concat(...arr.map(item => [].concat(item, ...flatten(item.subitems))))
}

// flatten方法结合find方法实现目录缩进
this.book.loaded.navigation.then(nav => {
  const navItem = flatten(nav.toc)
  function find(item, level = 0) {
    return !item.parent ? level : find(navItem.filter(parentItem =>
       parentItem.id === item.parent)[0], ++level)
  }
  navItem.forEach(item => {
    item.level = find(item)
  })
})
```



通过官方搜索算法实现了全文搜索功能，搜索关键字的高亮显示，以及精确跳转关键字的位置和阅读器中的文字高亮显示，重点研究了如何通过ES6将二维数组转变为一维数组。

```js
// 搜索方法封装
doSearch(q) {
  return Promise.all(
    this.currentBook.spine.spineItems.map(
      section => section.load(this.currentBook.load.bind(this.currentBook))
      .then(section.find.bind(section, q))
      .finally(section.unload.bind(section)))
  ).then(results => Promise.resolve([].concat.apply([], results)))
}

//全局搜索功能
search () {
  if (this.searchText && this.searchText.length > 0) {
    this.doSearch(this.searchText).then(list => {
      this.searchList = list
        // 二维数组转一维数组
      this.searchList.map(item => {
        item.excerpt = item.excerpt = item.excerpt.replace(this.searchText, `<span 			class="content-search-text">${this.searchText}</span>`)
        return item
      })
    })
  }
}
```



实现了书签功能，主要是通过touchmove和touchend事件实现了复杂的手势交互

手势操作的要点：

1. 通过绝对定位改变top值的方法实现了整个界面的下拉效果

   ```js
   // 下拉设置top值
   move (v) {
     this.$refs.ebook.style.top = v + 'px'
   }
   ```

2. 通过动态加载transition实现了界面的回弹动画

   ```js
   // 回弹动画设置
   restore () {
     this.$refs.ebook.style.top = 0
     this.$refs.ebook.style.transition = 'all .2s linear'
     setTimeout(() => {
       this.$refs.ebook.style.transition = ''
     }, 200)
   }
   ```

3. 通过css绘制了一个底部透明三角的书签

   ```css
   .bookmark {
     width: 0;
     height: 0;
     border-width: px2rem(36) px2rem(10) px2rem(10) px2rem(10);
     border-style: solid;
     border-color: white white transparent white;
   }
   ```

4. 设置了不同的状态来区分手势操作的不同阶段，触发不同的操作

   ```js
   // 状态1：未超过书签的高度
   beforeHeight () {
     if (this.isBookmark) {
       this.text = this.$t('book.pulldownDeleteMark')
       this.color = RED
       this.isFiexed = true
     } else {
       this.text = this.$t('book.pulldownAddMark')
       this.color = WHITE
       this.isFiexed = false
     }
   }
   
   //  状态2：未到达临界状态
   beforeThreshold (v) {
     this.$refs.bookmark.style.top = `${-v}px`
     this.beforeHeight()
     const iconDown = this.$refs.iconDown
     if (iconDown.style.transform === 'rotate(180deg)') {
       iconDown.style.transform = 'rotate(0deg)'
     }
   }
   
   // 状态3： 超越临界状态
   afterThreshold (v) {
     this.$refs.bookmark.style.top = `${-v}px`
     if (this.isBookmark) {
     this.text = this.$t('book.releaseDeleteMark')
     this.color = WHITE
     this.isFiexed = false
     } else {
       this.text = this.$t('book.releaseAddMark')
       this.color = RED
     this.isFiexed = true
     }
     const iconDown = this.$refs.iconDown
     if (iconDown.style.transform === '' || iconDown.style.transform ==='rotate(0deg)') {
       iconDown.style.transform = 'rotate(180deg)'
     }
   }
   
   // 状态4：书签归位
   restore () {
     setTimeout(() => {
       this.$refs.bookmark.style.top = `${-this.height}px`
       this.$refs.iconDown.style.transform = 'rotate(0deg)'
     }, 200)
     if (this.isFiexed) {
       this.setIsBookmark(true)
       this.addBookmark()
     } else {
       this.setIsBookmark(false)
       this.removeBookmark()
     }
   }
   ```



实现了添加书签的功能，比较重点的是如何获取当前书签所在页的文本内容。之后实现了书签删除的功能，主要是运用了ES6的filter方法做数组删除操作

```js
// 添加书签
addBookmark () {
  this.bookmark = getBookmark(this.fileName)
  if (!this.bookmark) {
    this.bookmark = []
  }
  const currentLocation = this.currentBook.rendition.currentLocation()
  const cfibase = currentLocation.start.cfi.replace(/!.*/, '')
  const cfistart = currentLocation.start.cfi.replace(/.*!/, '').replace(/\)$/, '')
  const cfiend = currentLocation.end.cfi.replace(/.*!/, '').replace(/\)$/, '')
  const cfirange = `${cfibase}!,${cfistart},${cfiend})`
  this.currentBook.getRange(cfirange).then(range => {
    const text = range.toString().replace(/\s\s/g, '')
    this.bookmark.push({
      cfi: currentLocation.start.cfi,
      text: text
    })
      // 存入localstroage
    saveBookmark(this.fileName, this.bookmark)
  })
}

// 删除书签
removeBookmark () {
  const currentLocation = this.currentBook.rendition.currentLocation()
  const cfi = currentLocation.start.cfi
  this.bookmark = getBookmark(this.fileName)
  if (this.bookmark) {
    saveBookmark(this.fileName, this.bookmark.filter(item => item.cfi !== cfi))
    this.setIsBookmark(false)
  }
}
```



添加了页眉和页脚，如何通过滚动模式阅读电子书，对微信端做了一些适配，同时兼容了PC端。兼容PC端的时候对css进行了一些优化，添加了对鼠标事件的支持，通过mousedown、mousemove、mouseup完成对书签下拉动画的支持。鼠标事件比手势事件更加复杂一点，通过四种状态来解决开发鼠标事件中的问题。

```js
// 鼠标事件的四种状态
// 1. 鼠标进入
// 2. 鼠标进入后的移动
// 3. 鼠标从移动状态松手
// 4. 鼠标还原

// 鼠标左键点击
onMouseEnter (e) {
  this.mouseState = 1
  this.mouseStartTime = e.timeStamp
  e.preventDefault()
  e.stopPropagation()
}

// 鼠标左键下拉
onMouseMove (e) {
  if (this.mouseState === 1) {
    this.mouseState = 2
  } else if (this.mouseState === 2) {
    let offsetY = 0
    if (this.firstOffsetY) {
      offsetY = e.clientY - this.firstOffsetY
      this.setOffsetY(offsetY)
    } else {
      this.firstOffsetY = e.clientY
    }
  }
  e.preventDefault()
  e.stopPropagation()
}

// 鼠标左键下拉松开还原
onMouseEnd (e) {
  if (this.mouseState === 2) {
    this.setOffsetY(0)
    this.firstOffsetY = null
    this.mouseState = 3
    e.preventDefault()
    e.stopPropagation()
  } else {
    this.mouseState = 4
  }
  const time = e.timeStamp - this.mouseStartTime
  if (time < 100) {
    this.mouseState = 4
  }
  e.preventDefault()
  e.stopPropagation()
}
```



实现了阅读器的分页算法

```js
// 阅读器的分页
this.book.ready.then(() => {
  return this.book.locations.generate(750 * (window.innerWidth / 375) *   (getFontSize(this.fileName) / 16))
  .then((locations) => {
    this.navigation.forEach(nav => {
      nav.pagelist = []
    })
    locations.forEach(item => {
      const loc = item.match(/\[(.*)\]!/)[1]
      this.navigation.forEach(nav => {
        if (nav.href) {
          const href = nav.href.match(/^(.*)\.html$/)[1]
          if (href === loc) {
            nav.pagelist.push(item)
          }
        }
      })
      let currentPage = 1
      this.navigation.forEach((nav, index) => {
        if (index === 0) {
          nav.page = 1
        } else {
          nav.page = currentPage
        }
        currentPage += nav.pagelist.length + 1
      })
    })
    this.setPageList(locations)
    this.setBookAvailable(true)
    this.refreshLocation()
  })
```



【非常深刻的理解到这种架构方式的优势：大大降低组件之间的耦合度，大幅度提高代码的可维护性可扩展性】